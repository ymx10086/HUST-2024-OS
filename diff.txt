diff --git a/Makefile b/Makefile
index 6cc2c0c..980e035 100755
--- a/Makefile
+++ b/Makefile
@@ -14,7 +14,6 @@ SRC_DIR        	:= .
 OBJ_DIR 		:= obj
 SPROJS_INCLUDE 	:= -I.  
 
-HOSTFS_ROOT := hostfs_root
 ifneq (,)
   march := -march=
   is_32bit := $(findstring 32,$(march))
@@ -64,17 +63,12 @@ SPIKE_INF_LIB   := $(OBJ_DIR)/spike_interface.a
 
 
 #---------------------	user   -----------------------
-USER_CPPS 		:= user/app_exec.c user/user_lib.c
+USER_CPPS 		:= user/*.c 
 
+USER_CPPS  		:= $(wildcard $(USER_CPPS))
 USER_OBJS  		:= $(addprefix $(OBJ_DIR)/, $(patsubst %.c,%.o,$(USER_CPPS)))
 
-USER_TARGET 	:= $(HOSTFS_ROOT)/bin/app_exec
-
-USER_E_CPPS 		:= user/app_ls.c user/user_lib.c
-
-USER_E_OBJS  		:= $(addprefix $(OBJ_DIR)/, $(patsubst %.c,%.o,$(USER_E_CPPS)))
-
-USER_E_TARGET 	:= $(HOSTFS_ROOT)/bin/app_ls
+USER_TARGET 	:= $(OBJ_DIR)/app_hardlink
 #------------------------targets------------------------
 $(OBJ_DIR):
 	@-mkdir -p $(OBJ_DIR)	
@@ -82,7 +76,6 @@ $(OBJ_DIR):
 	@-mkdir -p $(dir $(SPIKE_INF_OBJS))
 	@-mkdir -p $(dir $(KERNEL_OBJS))
 	@-mkdir -p $(dir $(USER_OBJS))
-	@-mkdir -p $(dir $(USER_E_OBJS))
 
 $(OBJ_DIR)/%.o : %.c
 	@echo "compiling" $<
@@ -109,28 +102,20 @@ $(KERNEL_TARGET): $(OBJ_DIR) $(UTIL_LIB) $(SPIKE_INF_LIB) $(KERNEL_OBJS) $(KERNE
 
 $(USER_TARGET): $(OBJ_DIR) $(UTIL_LIB) $(USER_OBJS)
 	@echo "linking" $@	...	
-	-@mkdir -p $(HOSTFS_ROOT)/bin
 	@$(COMPILE) --entry=main $(USER_OBJS) $(UTIL_LIB) -o $@
 	@echo "User app has been built into" \"$@\"
-	@cp $@ $(OBJ_DIR)
-
-$(USER_E_TARGET): $(OBJ_DIR) $(UTIL_LIB) $(USER_E_OBJS)
-	@echo "linking" $@	...	
-	-@mkdir -p $(HOSTFS_ROOT)/bin
-	@$(COMPILE) --entry=main $(USER_E_OBJS) $(UTIL_LIB) -o $@
-	@echo "User app has been built into" \"$@\"
 
 -include $(wildcard $(OBJ_DIR)/*/*.d)
 -include $(wildcard $(OBJ_DIR)/*/*/*.d)
 
 .DEFAULT_GOAL := $(all)
 
-all: $(KERNEL_TARGET) $(USER_TARGET) $(USER_E_TARGET)
+all: $(KERNEL_TARGET) $(USER_TARGET)
 .PHONY:all
 
-run: $(KERNEL_TARGET) $(USER_TARGET) $(USER_E_TARGET)
+run: $(KERNEL_TARGET) $(USER_TARGET)
 	@echo "********************HUST PKE********************"
-	spike $(KERNEL_TARGET) /bin/app_exec
+	spike $(KERNEL_TARGET) $(USER_TARGET)
 
 # need openocd!
 gdb:$(KERNEL_TARGET) $(USER_TARGET)
@@ -161,4 +146,4 @@ format:
 	@python ./format.py ./
 
 clean:
-	rm -fr ${OBJ_DIR} ${HOSTFS_ROOT}/bin
+	rm -fr ${OBJ_DIR}
diff --git a/hostfs_root/bin/app_exec b/hostfs_root/bin/app_exec
deleted file mode 100755
index 20d0a49..0000000
Binary files a/hostfs_root/bin/app_exec and /dev/null differ
diff --git a/hostfs_root/bin/app_ls b/hostfs_root/bin/app_ls
deleted file mode 100755
index 0744183..0000000
Binary files a/hostfs_root/bin/app_ls and /dev/null differ
diff --git a/hostfs_root/bin/app_read b/hostfs_root/bin/app_read
deleted file mode 100755
index b9e49f5..0000000
Binary files a/hostfs_root/bin/app_read and /dev/null differ
diff --git a/kernel/elf.c b/kernel/elf.c
index 509d419..5010a01 100755
--- a/kernel/elf.c
+++ b/kernel/elf.c
@@ -9,188 +9,164 @@
 #include "vmm.h"
 #include "pmm.h"
 #include "spike_interface/spike_utils.h"
-#include "vfs.h"
 
-typedef struct elf_info_t{
-	// spike_file_t *f;
-	struct file* f;
-	process *p;
+typedef struct elf_info_t {
+  spike_file_t *f;
+  process *p;
 } elf_info;
 
 //
 // the implementation of allocater. allocates memory space for later segment loading.
 // this allocater is heavily modified @lab2_1, where we do NOT work in bare mode.
 //
-static void *elf_alloc_mb(elf_ctx *ctx, uint64 elf_pa, uint64 elf_va, uint64 size){
-	elf_info *msg = (elf_info *)ctx->info;
-	// we assume that size of proram segment is smaller than a page.
-	kassert(size < PGSIZE);
-	void *pa = alloc_page();
-
-	if (pa == 0)
-		panic("uvmalloc mem alloc falied\n");
-
-	memset((void *)pa, 0, PGSIZE);
-	user_vm_map((pagetable_t)msg->p->pagetable, elf_va, PGSIZE, (uint64)pa,
-				prot_to_type(PROT_WRITE | PROT_READ | PROT_EXEC, 1));
-
-	return pa;
+static void *elf_alloc_mb(elf_ctx *ctx, uint64 elf_pa, uint64 elf_va, uint64 size) {
+  elf_info *msg = (elf_info *)ctx->info;
+  // we assume that size of proram segment is smaller than a page.
+  kassert(size < PGSIZE);
+  void *pa = alloc_page();
+  if (pa == 0) panic("uvmalloc mem alloc falied\n");
+
+  memset((void *)pa, 0, PGSIZE);
+  user_vm_map((pagetable_t)msg->p->pagetable, elf_va, PGSIZE, (uint64)pa,
+         prot_to_type(PROT_WRITE | PROT_READ | PROT_EXEC, 1));
+
+  return pa;
 }
 
 //
 // actual file reading, using the spike file interface.
 //
-static uint64 elf_fpread(elf_ctx *ctx, void *dest, uint64 nb, uint64 offset){
-	elf_info *msg = (elf_info *)ctx->info;
-	// call spike file utility to load the content of elf file into memory.
-	// spike_file_pread will read the elf file (msg->f) from offset to memory (indicated by
-	// *dest) for nb bytes.
-	// return spike_file_pread(msg->f, dest, nb, offset);
-	vfs_lseek(msg->f, offset, SEEK_SET);
-	return vfs_read(msg->f, dest, nb);
+static uint64 elf_fpread(elf_ctx *ctx, void *dest, uint64 nb, uint64 offset) {
+  elf_info *msg = (elf_info *)ctx->info;
+  // call spike file utility to load the content of elf file into memory.
+  // spike_file_pread will read the elf file (msg->f) from offset to memory (indicated by
+  // *dest) for nb bytes.
+  return spike_file_pread(msg->f, dest, nb, offset);
 }
 
 //
 // init elf_ctx, a data structure that loads the elf.
 //
-elf_status elf_init(elf_ctx *ctx, void *info){
-	ctx->info = info;
+elf_status elf_init(elf_ctx *ctx, void *info) {
+  ctx->info = info;
 
-	// load the elf header
-	if (elf_fpread(ctx, &ctx->ehdr, sizeof(ctx->ehdr), 0) != sizeof(ctx->ehdr))
-		return EL_EIO;
+  // load the elf header
+  if (elf_fpread(ctx, &ctx->ehdr, sizeof(ctx->ehdr), 0) != sizeof(ctx->ehdr)) return EL_EIO;
 
-	// check the signature (magic value) of the elf
-	if (ctx->ehdr.magic != ELF_MAGIC)
-		return EL_NOTELF;
+  // check the signature (magic value) of the elf
+  if (ctx->ehdr.magic != ELF_MAGIC) return EL_NOTELF;
 
-	return EL_OK;
+  return EL_OK;
 }
 
 //
 // load the elf segments to memory regions.
 //
-elf_status elf_load(elf_ctx *ctx){
-	// elf_prog_header structure is defined in kernel/elf.h
-	elf_prog_header ph_addr;
-	int i, off;
-
-	// traverse the elf program segment headers
-	for (i = 0, off = ctx->ehdr.phoff; i < ctx->ehdr.phnum; i++, off += sizeof(ph_addr))
-	{
-		// read segment headers
-		if (elf_fpread(ctx, (void *)&ph_addr, sizeof(ph_addr), off) != sizeof(ph_addr))
-			return EL_EIO;
-
-		if (ph_addr.type != ELF_PROG_LOAD)
-			continue;
-		if (ph_addr.memsz < ph_addr.filesz)
-			return EL_ERR;
-		if (ph_addr.vaddr + ph_addr.memsz < ph_addr.vaddr)
-			return EL_ERR;
-
-		// allocate memory block before elf loading
-		void *dest = elf_alloc_mb(ctx, ph_addr.vaddr, ph_addr.vaddr, ph_addr.memsz);
-
-		// actual loading
-		if (elf_fpread(ctx, dest, ph_addr.memsz, ph_addr.off) != ph_addr.memsz)
-			return EL_EIO;
-
-		// record the vm region in proc->mapped_info. added @lab3_1
-		int j;
-		for (j = 0; j < PGSIZE / sizeof(mapped_region); j++) // seek the last mapped region
-			if ((process *)(((elf_info *)(ctx->info))->p)->mapped_info[j].va == 0x0)
-				break;
-
-		((process *)(((elf_info *)(ctx->info))->p))->mapped_info[j].va = ph_addr.vaddr;
-		((process *)(((elf_info *)(ctx->info))->p))->mapped_info[j].npages = 1;
-
-		// SEGMENT_READABLE, SEGMENT_EXECUTABLE, SEGMENT_WRITABLE are defined in kernel/elf.h
-		if (ph_addr.flags == (SEGMENT_READABLE | SEGMENT_EXECUTABLE))
-		{
-			((process *)(((elf_info *)(ctx->info))->p))->mapped_info[j].seg_type = CODE_SEGMENT;
-			sprint("CODE_SEGMENT added at mapped info offset:%d\n", j);
-		}
-		else if (ph_addr.flags == (SEGMENT_READABLE | SEGMENT_WRITABLE))
-		{
-			((process *)(((elf_info *)(ctx->info))->p))->mapped_info[j].seg_type = DATA_SEGMENT;
-			sprint("DATA_SEGMENT added at mapped info offset:%d\n", j);
-		}
-		else
-			panic("unknown program segment encountered, segment flag:%d.\n", ph_addr.flags);
-
-		((process *)(((elf_info *)(ctx->info))->p))->total_mapped_region++;
-	}
-
-	return EL_OK;
+elf_status elf_load(elf_ctx *ctx) {
+  // elf_prog_header structure is defined in kernel/elf.h
+  elf_prog_header ph_addr;
+  int i, off;
+
+  // traverse the elf program segment headers
+  for (i = 0, off = ctx->ehdr.phoff; i < ctx->ehdr.phnum; i++, off += sizeof(ph_addr)) {
+    // read segment headers
+    if (elf_fpread(ctx, (void *)&ph_addr, sizeof(ph_addr), off) != sizeof(ph_addr)) return EL_EIO;
+
+    if (ph_addr.type != ELF_PROG_LOAD) continue;
+    if (ph_addr.memsz < ph_addr.filesz) return EL_ERR;
+    if (ph_addr.vaddr + ph_addr.memsz < ph_addr.vaddr) return EL_ERR;
+
+    // allocate memory block before elf loading
+    void *dest = elf_alloc_mb(ctx, ph_addr.vaddr, ph_addr.vaddr, ph_addr.memsz);
+
+    // actual loading
+    if (elf_fpread(ctx, dest, ph_addr.memsz, ph_addr.off) != ph_addr.memsz)
+      return EL_EIO;
+
+    // record the vm region in proc->mapped_info. added @lab3_1
+    int j;
+    for( j=0; j<PGSIZE/sizeof(mapped_region); j++ ) //seek the last mapped region
+      if( (process*)(((elf_info*)(ctx->info))->p)->mapped_info[j].va == 0x0 ) break;
+
+    ((process*)(((elf_info*)(ctx->info))->p))->mapped_info[j].va = ph_addr.vaddr;
+    ((process*)(((elf_info*)(ctx->info))->p))->mapped_info[j].npages = 1;
+
+    // SEGMENT_READABLE, SEGMENT_EXECUTABLE, SEGMENT_WRITABLE are defined in kernel/elf.h
+    if( ph_addr.flags == (SEGMENT_READABLE|SEGMENT_EXECUTABLE) ){
+      ((process*)(((elf_info*)(ctx->info))->p))->mapped_info[j].seg_type = CODE_SEGMENT;
+      sprint( "CODE_SEGMENT added at mapped info offset:%d\n", j );
+    }else if ( ph_addr.flags == (SEGMENT_READABLE|SEGMENT_WRITABLE) ){
+      ((process*)(((elf_info*)(ctx->info))->p))->mapped_info[j].seg_type = DATA_SEGMENT;
+      sprint( "DATA_SEGMENT added at mapped info offset:%d\n", j );
+    }else
+      panic( "unknown program segment encountered, segment flag:%d.\n", ph_addr.flags );
+
+    ((process*)(((elf_info*)(ctx->info))->p))->total_mapped_region ++;
+  }
+
+  return EL_OK;
 }
 
-typedef union{
-	uint64 buf[MAX_CMDLINE_ARGS];
-	char *argv[MAX_CMDLINE_ARGS];
+typedef union {
+  uint64 buf[MAX_CMDLINE_ARGS];
+  char *argv[MAX_CMDLINE_ARGS];
 } arg_buf;
 
 //
 // returns the number (should be 1) of string(s) after PKE kernel in command line.
 // and store the string(s) in arg_bug_msg.
 //
-static size_t parse_args(arg_buf *arg_bug_msg){
-	// HTIFSYS_getmainvars frontend call reads command arguments to (input) *arg_bug_msg
-	long r = frontend_syscall(HTIFSYS_getmainvars, (uint64)arg_bug_msg,
-							  sizeof(*arg_bug_msg), 0, 0, 0, 0, 0);
-	kassert(r == 0);
+static size_t parse_args(arg_buf *arg_bug_msg) {
+  // HTIFSYS_getmainvars frontend call reads command arguments to (input) *arg_bug_msg
+  long r = frontend_syscall(HTIFSYS_getmainvars, (uint64)arg_bug_msg,
+      sizeof(*arg_bug_msg), 0, 0, 0, 0, 0);
+  kassert(r == 0);
 
-	size_t pk_argc = arg_bug_msg->buf[0];
-	uint64 *pk_argv = &arg_bug_msg->buf[1];
+  size_t pk_argc = arg_bug_msg->buf[0];
+  uint64 *pk_argv = &arg_bug_msg->buf[1];
 
-	int arg = 1; // skip the PKE OS kernel string, leave behind only the application name
-	for (size_t i = 0; arg + i < pk_argc; i++)
-		arg_bug_msg->argv[i] = (char *)(uintptr_t)pk_argv[arg + i];
+  int arg = 1;  // skip the PKE OS kernel string, leave behind only the application name
+  for (size_t i = 0; arg + i < pk_argc; i++)
+    arg_bug_msg->argv[i] = (char *)(uintptr_t)pk_argv[arg + i];
 
-	// returns the number of strings after PKE kernel in command line
-	return pk_argc - arg;
+  //returns the number of strings after PKE kernel in command line
+  return pk_argc - arg;
 }
 
 //
 // load the elf of user application, by using the spike file interface.
 //
-void load_bincode_from_host_elf(process *p){
-	arg_buf arg_bug_msg;
-
-	// retrieve command line arguements
-	size_t argc = parse_args(&arg_bug_msg);
-	if (!argc)
-		panic("You need to specify the application program!\n");
+void load_bincode_from_host_elf(process *p) {
+  arg_buf arg_bug_msg;
 
-	sprint("Application: %s\n", arg_bug_msg.argv[0]);
+  // retrieve command line arguements
+  size_t argc = parse_args(&arg_bug_msg);
+  if (!argc) panic("You need to specify the application program!\n");
 
-	// elf loading. elf_ctx is defined in kernel/elf.h, used to track the loading process.
-	elf_ctx elfloader;
-	// elf_info is defined above, used to tie the elf file and its corresponding process.
-	elf_info info;
+  sprint("Application: %s\n", arg_bug_msg.argv[0]);
 
-	// info.f = spike_file_open(arg_bug_msg.argv[0], O_RDONLY, 0);
-	info.f = vfs_open(arg_bug_msg.argv[0], O_RDONLY);
+  //elf loading. elf_ctx is defined in kernel/elf.h, used to track the loading process.
+  elf_ctx elfloader;
+  // elf_info is defined above, used to tie the elf file and its corresponding process.
+  elf_info info;
 
-	info.p = p;
-	// IS_ERR_VALUE is a macro defined in spike_interface/spike_htif.h
-	if (IS_ERR_VALUE(info.f))
-		panic("Fail on openning the input application program.\n");
+  info.f = spike_file_open(arg_bug_msg.argv[0], O_RDONLY, 0);
+  info.p = p;
+  // IS_ERR_VALUE is a macro defined in spike_interface/spike_htif.h
+  if (IS_ERR_VALUE(info.f)) panic("Fail on openning the input application program.\n");
 
-	// init elfloader context. elf_init() is defined above.
-	if (elf_init(&elfloader, &info) != EL_OK)
-		panic("fail to init elfloader.\n");
+  // init elfloader context. elf_init() is defined above.
+  if (elf_init(&elfloader, &info) != EL_OK)
+    panic("fail to init elfloader.\n");
 
-	// load elf. elf_load() is defined above.
-	if (elf_load(&elfloader) != EL_OK)
-		panic("Fail on loading elf.\n");
+  // load elf. elf_load() is defined above.
+  if (elf_load(&elfloader) != EL_OK) panic("Fail on loading elf.\n");
 
-	// entry (virtual, also physical in lab1_x) address
-	p->trapframe->epc = elfloader.ehdr.entry;
+  // entry (virtual, also physical in lab1_x) address
+  p->trapframe->epc = elfloader.ehdr.entry;
 
-	// close the host spike file
-	// spike_file_close(info.f);
-	vfs_close(info.f);
+  // close the host spike file
+  spike_file_close( info.f );
 
-	sprint("Application program entry point (virtual address): 0x%lx\n", p->trapframe->epc);
+  sprint("Application program entry point (virtual address): 0x%lx\n", p->trapframe->epc);
 }
diff --git a/kernel/proc_file.c b/kernel/proc_file.c
index f25fdc9..3d99cbb 100644
--- a/kernel/proc_file.c
+++ b/kernel/proc_file.c
@@ -15,10 +15,6 @@
 #include "util/functions.h"
 #include "util/string.h"
 
-#include "elf.h"
-#include "vmm.h"
-#include "memlayout.h"
-
 //
 // initialize file system
 //
@@ -225,65 +221,3 @@ int do_link(char *oldpath, char *newpath) {
 int do_unlink(char *path) {
   return vfs_unlink(path);
 }
-
-// load exec
-static void exec_bincode(process *p, char *path){
-    sprint("Application: %s\n", path);
-    int fp = do_open(path, O_RDONLY);
-    spike_file_t *f = (spike_file_t *)(get_opened_file(fp)->f_dentry->dentry_inode->i_fs_info); 
-    elf_header ehdr;
-    if (spike_file_read(f, &ehdr, sizeof(elf_header)) != sizeof(elf_header)){
-        panic("read elf header error\n");
-    }
-
-    // load the code_segmant and data_segmant
-    elf_prog_header ph_addr;
-    for (int i = 0, off = ehdr.phoff; i < ehdr.phnum; i++, off += sizeof(ph_addr)){
-        
-        spike_file_lseek(f, off, SEEK_SET); // seek to the program header
-        if (spike_file_read(f, &ph_addr, sizeof(ph_addr)) != sizeof(ph_addr))
-            panic("read elf program header error\n");
-        if (ph_addr.type != ELF_PROG_LOAD) continue;
-
-        void *pa = alloc_page(); 
-        memset(pa, 0, PGSIZE);
-        user_vm_map((pagetable_t)p->pagetable, ph_addr.vaddr, PGSIZE, (uint64)pa, prot_to_type(PROT_WRITE | PROT_READ | PROT_EXEC, 1));
-        spike_file_lseek(f, ph_addr.off, SEEK_SET);
-        if (spike_file_read(f, pa, ph_addr.memsz) != ph_addr.memsz)
-        {
-            panic("read program segment error.\n");
-        }
-
-        int pos;
-        for (pos = 0; pos < PGSIZE / sizeof(mapped_region); pos++) // seek the last mapped region
-            if (p->mapped_info[pos].va == 0x0)
-                break;
-
-        p->mapped_info[pos].va = ph_addr.vaddr;
-        p->mapped_info[pos].npages = 1;
-
-        // SEGMENT_READABLE, SEGMENT_EXECUTABLE, SEGMENT_WRITABLE are defined in kernel/elf.h
-        if (ph_addr.flags == (SEGMENT_READABLE | SEGMENT_EXECUTABLE)){
-            p->mapped_info[pos].seg_type = CODE_SEGMENT;
-            sprint("CODE_SEGMENT added at mapped info offset:%d\n", pos);
-        }
-        else if (ph_addr.flags == (SEGMENT_READABLE | SEGMENT_WRITABLE)){
-            p->mapped_info[pos].seg_type = DATA_SEGMENT;
-            sprint("DATA_SEGMENT added at mapped info offset:%d\n", pos);
-        }
-        else
-            panic("unknown program segment encountered, segment flag:%d.\n", ph_addr.flags);
-
-        p->total_mapped_region++;
-    }
-    
-    p->trapframe->epc = ehdr.entry;
-    do_close(fp); 
-    sprint("Application program entry point (virtual address): 0x%lx\n", p->trapframe->epc);
-}
-
-int do_exec(char *path){
-    exec_clean(current);
-    exec_bincode(current, path);
-    return -1;
-}
\ No newline at end of file
diff --git a/kernel/proc_file.h b/kernel/proc_file.h
index 27a8dc2..2cfb051 100644
--- a/kernel/proc_file.h
+++ b/kernel/proc_file.h
@@ -24,9 +24,6 @@ int do_closedir(int fd);
 int do_link(char *oldpath, char *newpath);
 int do_unlink(char *path);
 
-// ADD
-int do_exec(char *path);
-
 void fs_init(void);
 
 // data structure that manages all openned files in a PCB
diff --git a/kernel/process.c b/kernel/process.c
index a2cb1bb..bfe9ac2 100755
--- a/kernel/process.c
+++ b/kernel/process.c
@@ -199,7 +199,7 @@ int do_fork(process *parent) {
 
         for (int j = 0; j < parent->mapped_info[i].npages; j++) {
           uint64 pa_of_mapped_va = lookup_pa(parent->pagetable, parent->mapped_info[i].va + j * PGSIZE);
-
+          // 建立父进程位于 pa_of_mapped_va 的代码段与子进程对应逻辑地址的映射
           map_pages(child->pagetable, parent->mapped_info[i].va + j * PGSIZE, PGSIZE, pa_of_mapped_va, prot_to_type(PROT_READ | PROT_EXEC, 1));
         }
 
@@ -219,80 +219,4 @@ int do_fork(process *parent) {
   insert_to_ready_queue(child);
 
   return child->pid;
-}
-
-// realease three level pagetable
-static void exec_clean_pagetable(pagetable_t page_dir) {
-
-    for (int i = 0; i < PGSIZE / sizeof(pte_t); i++) {
-        pte_t* pte1 = page_dir + i;
-        if (*pte1 & PTE_V) {
-            pagetable_t page_mid_dir = (pagetable_t)PTE2PA(*pte1);
-            for (int j = 0; j < PGSIZE / sizeof(pte_t); j++) {
-                pte_t* pte2 = page_mid_dir + j;
-                if (*pte2 & PTE_V) {
-                    pagetable_t page_low_dir = (pagetable_t)PTE2PA(*pte2);
-                    for (int k = 0; k < PGSIZE / sizeof(pte_t); k++) {
-                        pte_t* pte3 = page_low_dir + k;
-                        if (*pte3 & PTE_V) {
-                            if (*pte3 & PTE_W) {
-                                uint64 page = PTE2PA(*pte3);
-                                free_page((void *)page); 
-                            }
-                            (*pte3) &= ~PTE_V; 
-                        }
-                    }
-                    free_page((void *)page_low_dir);
-                }
-            }
-            free_page((void *)page_mid_dir);
-        }
-    }
-    free_page((void *)page_dir);
-
-}
-
-// release three level pagetable
-void exec_clean(process* p) {
-    exec_clean_pagetable(p->pagetable);
-    
-    // init proc[i]'s vm space
-    p->trapframe = (trapframe *)alloc_page(); // trapframe, used to save context 
-    memset(p->trapframe, 0, sizeof(trapframe));
-
-    // page directory
-    p->pagetable = (pagetable_t)alloc_page();
-    memset((void *)p->pagetable, 0, PGSIZE);
-
-    p->kstack = (uint64)alloc_page() + PGSIZE; // user kernel stack top
-    uint64 user_stack = (uint64)alloc_page();        // phisical address of user stack bottom
-    p->trapframe->regs.sp = USER_STACK_TOP;    // virtual address of user stack top
-
-    // allocates a page to record memory regions (segments)
-    p->mapped_info = (mapped_region *)alloc_page();
-    memset(p->mapped_info, 0, PGSIZE);
-
-    // map user stack in userspace
-    user_vm_map((pagetable_t)p->pagetable, USER_STACK_TOP - PGSIZE, PGSIZE,
-                user_stack, prot_to_type(PROT_WRITE | PROT_READ, 1));
-    p->mapped_info[STACK_SEGMENT].va = USER_STACK_TOP - PGSIZE;
-    p->mapped_info[STACK_SEGMENT].npages = 1;
-    p->mapped_info[STACK_SEGMENT].seg_type = STACK_SEGMENT;
-
-    // map trapframe in user space (direct mapping as in kernel space).
-    user_vm_map((pagetable_t)p->pagetable, (uint64)p->trapframe, PGSIZE, // trapframe的物理地址等于虚拟地址
-                (uint64)p->trapframe, prot_to_type(PROT_WRITE | PROT_READ, 0));
-    p->mapped_info[CONTEXT_SEGMENT].va = (uint64)p->trapframe;
-    p->mapped_info[CONTEXT_SEGMENT].npages = 1;
-    p->mapped_info[CONTEXT_SEGMENT].seg_type = CONTEXT_SEGMENT;
-
-    // map S-mode trap vector section in user space (direct mapping as in kernel space)
-    // we assume that the size of usertrap.S is smaller than a page.
-    user_vm_map((pagetable_t)p->pagetable, (uint64)trap_sec_start, PGSIZE,
-                (uint64)trap_sec_start, prot_to_type(PROT_READ | PROT_EXEC, 0));
-    p->mapped_info[SYSTEM_SEGMENT].va = (uint64)trap_sec_start;
-    p->mapped_info[SYSTEM_SEGMENT].npages = 1;
-    p->mapped_info[SYSTEM_SEGMENT].seg_type = SYSTEM_SEGMENT;
-
-    p->parent = NULL; 
 }
\ No newline at end of file
diff --git a/kernel/process.h b/kernel/process.h
index d45bc1b..5f4c63b 100755
--- a/kernel/process.h
+++ b/kernel/process.h
@@ -110,7 +110,4 @@ int do_fork(process* parent);
 // current running process
 extern process* current;
 
-// release three level pagetable
-void exec_clean(process* p);
-
 #endif
diff --git a/kernel/syscall.c b/kernel/syscall.c
index a48ff91..b839143 100755
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -216,11 +216,6 @@ ssize_t sys_user_unlink(char * vfn){
   return do_unlink(pfn);
 }
 
-int sys_user_exec(char *pathva) {
-  char *pathpa = (char*)user_va_to_pa((pagetable_t)(current->pagetable), pathva);
-  return do_exec(pathpa);
-}
-
 //
 // [a0]: the syscall number; [a1] ... [a7]: arguments to the syscalls.
 // returns the code of success, (e.g., 0 means success, fail for otherwise)
@@ -269,8 +264,6 @@ long do_syscall(long a0, long a1, long a2, long a3, long a4, long a5, long a6, l
       return sys_user_link((char *)a1, (char *)a2);
     case SYS_user_unlink:
       return sys_user_unlink((char *)a1);
-    case SYS_user_exec:
-      return sys_user_exec((char *)a1);
     default:
       panic("Unknown syscall %ld \n", a0);
   }
diff --git a/kernel/syscall.h b/kernel/syscall.h
index f5fe287..0486c81 100755
--- a/kernel/syscall.h
+++ b/kernel/syscall.h
@@ -31,8 +31,6 @@
 #define SYS_user_link   (SYS_user_base + 28)
 #define SYS_user_unlink (SYS_user_base + 29)
 
-#define SYS_user_exec (SYS_user_base + 30)
-
 long do_syscall(long a0, long a1, long a2, long a3, long a4, long a5, long a6, long a7);
 
 #endif
diff --git a/user/app_exec.c b/user/app_exec.c
deleted file mode 100644
index 3b78bf2..0000000
--- a/user/app_exec.c
+++ /dev/null
@@ -1,26 +0,0 @@
-// #include "user_lib.h"
-// #include "util/types.h"
-
-// int main(int argc, char *argv[]) {
-//   printu("\n======== exec /bin/app_ls in app_exec ========\n");
-//   int ret = exec("/bin/app_ls");
-//   if (ret == -1)
-//     printu("exec failed!\n");
-
-//   exit(0);
-//   return 0;
-// }
-
-#include "user_lib.h"
-#include "util/types.h"
-
-int main(int argc, char *argv[]) {
-  printu("\n======== exec /bin/app_read in app_exec ========\n");
-  printu("call exec in main\n");
-  int ret = exec("/bin/app_read");
-  if (ret == -1)
-    printu("exec failed!\n");
-
-  exit(0);
-  return 0;
-}
diff --git a/user/app_hardlink.c b/user/app_hardlink.c
new file mode 100644
index 0000000..7e209e5
--- /dev/null
+++ b/user/app_hardlink.c
@@ -0,0 +1,94 @@
+#include "user_lib.h"
+#include "util/string.h"
+#include "util/types.h"
+
+void ls(char *path) {
+  int dir_fd = opendir_u(path);
+  printu("------------------------------\n");
+  printu("ls \"%s\":\n", path);
+  printu("[name]               [inode_num]\n");
+  struct dir dir;
+  int width = 20;
+  while(readdir_u(dir_fd, &dir) == 0) {
+    // we do not have %ms :(
+    char name[width + 1];
+    memset(name, ' ', width + 1);
+    name[width] = '\0';
+    if (strlen(dir.name) < width) {
+      strcpy(name, dir.name);
+      name[strlen(dir.name)] = ' ';
+      printu("%s %d\n", name, dir.inum);
+    }
+    else
+      printu("%s %d\n", dir.name, dir.inum);
+  }
+  printu("------------------------------\n");
+  closedir_u(dir_fd);
+}
+
+int main(int argc, char *argv[]) {
+  int MAXBUF = 512;
+  char str[] = "hello world";
+  char buf[MAXBUF];
+  int fd1, fd2;
+  
+  printu("\n======== establish the file ========\n");
+
+  fd1 = open("/RAMDISK0/ramfile", O_RDWR | O_CREAT);
+  printu("create file: /RAMDISK0/ramfile\n");
+  close(fd1);
+
+  printu("\n======== Test 1: hard link ========\n");
+
+  link_u("/RAMDISK0/ramfile", "/RAMDISK0/ramfile2");
+  printu("create hard link: /RAMDISK0/ramfile2 -> /RAMDISK0/ramfile\n");
+
+  fd1 = open("/RAMDISK0/ramfile", O_RDWR);
+  fd2 = open("/RAMDISK0/ramfile2", O_RDWR);
+  
+  printu("file descriptor fd1 (ramfile): %d\n", fd1);
+  printu("file descriptor fd2 (ramfile2): %d\n", fd2);
+
+  // check the number of hard links to ramfile on disk
+  struct istat st;
+  disk_stat_u(fd1, &st);
+  printu("ramfile hard links: %d\n", st.st_nlinks);
+  if (st.st_nlinks != 2) {
+    printu("ERROR: the number of hard links to ramfile should be 2, but it is %d\n",
+             st.st_nlinks);
+    exit(-1);
+  }
+  
+  write_u(fd1, str, strlen(str));
+  printu("/RAMDISK0/ramfile write content: \n%s\n", str);
+
+  read_u(fd2, buf, MAXBUF);
+  printu("/RAMDISK0/ramfile2 read content: \n%s\n", buf);
+
+  close(fd1);
+  close(fd2);
+
+  printu("\n======== Test 2: unlink ========\n");
+
+  ls("/RAMDISK0");
+
+  unlink_u("/RAMDISK0/ramfile");
+  printu("unlink: /RAMDISK0/ramfile\n");
+
+  ls("/RAMDISK0");
+
+  // check the number of hard links to ramfile2 on disk
+  fd2 = open("/RAMDISK0/ramfile2", O_RDWR);
+  disk_stat_u(fd2, &st);
+  printu("ramfile2 hard links: %d\n", st.st_nlinks);
+  if (st.st_nlinks != 1) {
+    printu("ERROR: the number of hard links to ramfile should be 1, but it is %d\n",
+             st.st_nlinks);
+    exit(-1);
+  }
+  close(fd2);
+
+  printu("\nAll tests passed!\n\n");
+  exit(0);
+  return 0;
+}
diff --git a/user/app_ls.c b/user/app_ls.c
deleted file mode 100644
index dc74462..0000000
--- a/user/app_ls.c
+++ /dev/null
@@ -1,31 +0,0 @@
-#include "user_lib.h"
-#include "util/string.h"
-#include "util/types.h"
-
-int main(int argc, char *argv[]) {
-  char path[] = "/RAMDISK0";
-  int dir_fd = opendir_u(path);
-  printu("------------------------------\n");
-  printu("ls \"%s\":\n", path);
-  printu("[name]               [inode_num]\n");
-  struct dir dir;
-  int width = 20;
-  while(readdir_u(dir_fd, &dir) == 0) {
-    // we do not have %ms :(
-    char name[width + 1];
-    memset(name, ' ', width + 1);
-    name[width] = '\0';
-    if (strlen(dir.name) < width) {
-      strcpy(name, dir.name);
-      name[strlen(dir.name)] = ' ';
-      printu("%s %d\n", name, dir.inum);
-    }
-    else
-      printu("%s %d\n", dir.name, dir.inum);
-  }
-  printu("------------------------------\n");
-  closedir_u(dir_fd);
-
-  exit(0);
-  return 0;
-}
\ No newline at end of file
diff --git a/user/app_read.c b/user/app_read.c
deleted file mode 100644
index e8295d0..0000000
--- a/user/app_read.c
+++ /dev/null
@@ -1,22 +0,0 @@
- #include "user_lib.h"
-#include "util/string.h"
-#include "util/types.h"
-
-int main(int argc, char *argv[]) {
-  int fd;
-  int MAXBUF = 512;
-  char buf[MAXBUF];
-  printu("------------------------------\n");
-  printu("read: /hostfile.txt\n");
-
-  fd = open("/hostfile.txt", O_RDONLY);
-  printu("file descriptor fd: %d\n", fd);
-
-  read_u(fd, buf, MAXBUF);
-  printu("read content: \n%s\n", buf);
-  printu("------------------------------\n");
-  close(fd);
-
-  exit(0);
-  return 0;
-}
\ No newline at end of file
diff --git a/user/user_lib.c b/user/user_lib.c
index 946c8da..1c4f6d1 100755
--- a/user/user_lib.c
+++ b/user/user_lib.c
@@ -167,10 +167,3 @@ int unlink_u(const char *fn){
 int close(int fd) {
   return do_user_call(SYS_user_close, fd, 0, 0, 0, 0, 0, 0);
 }
-
-//
-// lib call to exec
-//
-int exec(const char *path) {
-  return do_user_call(SYS_user_exec, (uint64)path, 0, 0, 0, 0, 0, 0);
-}
diff --git a/user/user_lib.h b/user/user_lib.h
index 9e94e13..95a686d 100755
--- a/user/user_lib.h
+++ b/user/user_lib.h
@@ -33,6 +33,5 @@ int closedir_u(int fd);
 int link_u(const char *fn1, const char *fn2);
 int unlink_u(const char *fn);
 
-int exec(const char *path);
 
 #endif
